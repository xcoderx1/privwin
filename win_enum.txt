<#
.SYNOPSIS
    Ultimate Windows Privilege Escalation Enumeration Tool
.DESCRIPTION
    Comprehensive enumeration of 40+ privilege escalation vectors
.NOTES
    For authorized security assessments only
    Version: 2.0
#>

param(
    [switch]$Verbose,
    [switch]$SaveReport,
    [string]$OutputPath = ".\PrivEscEnum_Report.txt"
)

# Color coding for output
function Write-Finding {
    param(
        [string]$Message,
        [string]$Level = "Info"
    )
    
    switch ($Level) {
        "Critical" { Write-Host "[!] $Message" -ForegroundColor Red }
        "High"     { Write-Host "[+] $Message" -ForegroundColor Yellow }
        "Medium"   { Write-Host "[*] $Message" -ForegroundColor Cyan }
        "Info"     { Write-Host "[i] $Message" -ForegroundColor White }
    }
    
    if ($SaveReport) {
        Add-Content -Path $OutputPath -Value "[$Level] $Message"
    }
}

function Write-SectionHeader {
    param([string]$Title)
    $separator = "=" * 80
    Write-Host "`n$separator" -ForegroundColor Green
    Write-Host $Title -ForegroundColor Green
    Write-Host "$separator`n" -ForegroundColor Green
    
    if ($SaveReport) {
        Add-Content -Path $OutputPath -Value "`n$separator`n$Title`n$separator`n"
    }
}

# Initialize report
if ($SaveReport) {
    "Windows Privilege Escalation Enumeration Report" | Out-File -FilePath $OutputPath
    "Generated: $(Get-Date)" | Out-File -FilePath $OutputPath -Append
    "Host: $env:COMPUTERNAME" | Out-File -FilePath $OutputPath -Append
}

Write-Host "`n================================================================" -ForegroundColor Cyan
Write-Host "   Ultimate Windows Privilege Escalation Enumeration Tool" -ForegroundColor Cyan
Write-Host "   Comprehensive Security Assessment - 40+ Checks" -ForegroundColor Cyan
Write-Host "================================================================`n" -ForegroundColor Cyan

# ============================================================================
# SYSTEM INFORMATION
# ============================================================================
Write-SectionHeader "SYSTEM INFORMATION"

try {
    $os = Get-WmiObject -Class Win32_OperatingSystem
    Write-Finding "OS: $($os.Caption) $($os.OSArchitecture)" "Info"
    Write-Finding "Version: $($os.Version)" "Info"
    Write-Finding "Build: $($os.BuildNumber)" "Info"
    Write-Finding "Hostname: $env:COMPUTERNAME" "Info"
    
    Write-Finding "Checking installed hotfixes..." "Info"
    $hotfixes = Get-HotFix | Select-Object -ExpandProperty HotFixID
    Write-Finding "Total Hotfixes Installed: $($hotfixes.Count)" "Info"
    
} catch {
    Write-Finding "Error gathering system information: $_" "High"
}

# ============================================================================
# CURRENT USER INFORMATION
# ============================================================================
Write-SectionHeader "CURRENT USER INFORMATION"

try {
    $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    Write-Finding "Username: $($currentUser.Name)" "Info"
    
    Write-Finding "User Privileges:" "Info"
    $privileges = whoami /priv
    $privileges | ForEach-Object { Write-Finding $_ "Info" }
    
    Write-Finding "`nGroup Memberships:" "Info"
    $groups = whoami /groups
    $groups | ForEach-Object { Write-Finding $_ "Info" }
    
    # Check for dangerous privileges
    if ($privileges -match "SeImpersonatePrivilege.*Enabled") {
        Write-Finding "SeImpersonatePrivilege is ENABLED - Token impersonation possible!" "Critical"
        Write-Finding "  Exploit: PrintSpoofer, RoguePotato, GodPotato" "Critical"
    }
    if ($privileges -match "SeAssignPrimaryTokenPrivilege.*Enabled") {
        Write-Finding "SeAssignPrimaryTokenPrivilege is ENABLED" "High"
    }
    if ($privileges -match "SeDebugPrivilege.*Enabled") {
        Write-Finding "SeDebugPrivilege is ENABLED - Can debug/inject into processes!" "High"
    }
    if ($privileges -match "SeBackupPrivilege.*Enabled") {
        Write-Finding "SeBackupPrivilege is ENABLED - Can backup/read any file!" "High"
        Write-Finding "  Exploit: robocopy /b to copy SAM/SYSTEM" "High"
    }
    if ($privileges -match "SeRestorePrivilege.*Enabled") {
        Write-Finding "SeRestorePrivilege is ENABLED - Can restore/write any file!" "High"
    }
    if ($privileges -match "SeTakeOwnershipPrivilege.*Enabled") {
        Write-Finding "SeTakeOwnershipPrivilege is ENABLED - Can take ownership!" "High"
    }
    if ($privileges -match "SeLoadDriverPrivilege.*Enabled") {
        Write-Finding "SeLoadDriverPrivilege is ENABLED - Can load kernel drivers!" "Critical"
    }
    
} catch {
    Write-Finding "Error gathering user information: $_" "High"
}

# ============================================================================
# ALWAYSINSTALLELEVATED REGISTRY CHECK
# ============================================================================
Write-SectionHeader "ALWAYSINSTALLELEVATED CHECK"

try {
    $hklm = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue
    $hkcu = Get-ItemProperty -Path "HKCU:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue
    
    if ($hklm.AlwaysInstallElevated -eq 1 -and $hkcu.AlwaysInstallElevated -eq 1) {
        Write-Finding "VULNERABLE! AlwaysInstallElevated is enabled!" "Critical"
        Write-Finding "  Exploit: msfvenom -f msi to create malicious installer" "Critical"
    } else {
        Write-Finding "AlwaysInstallElevated is not enabled" "Info"
    }
} catch {
    Write-Finding "Could not check AlwaysInstallElevated" "Info"
}

# ============================================================================
# SERVICES ENUMERATION
# ============================================================================
Write-SectionHeader "SERVICES WITH POTENTIAL ISSUES"

try {
    Write-Finding "Checking for services with weak permissions..." "Info"
    
    $services = Get-WmiObject win32_service
    
    foreach ($service in $services) {
        # Unquoted service paths
        if ($service.PathName -match '^[^"].*\s.*') {
            Write-Finding "Unquoted Service Path: $($service.Name) - $($service.PathName)" "High"
            Write-Finding "  Exploit: Place exe in path with space" "High"
        }
        
        # Writable service binaries
        if ($service.PathName) {
            $binaryPath = $service.PathName -replace '"', '' -replace ' .*$', ''
            if (Test-Path $binaryPath -ErrorAction SilentlyContinue) {
                try {
                    $testFile = $binaryPath + ".test"
                    [System.IO.File]::Create($testFile).Close()
                    Remove-Item $testFile -ErrorAction SilentlyContinue
                    Write-Finding "Writable Service Binary: $($service.Name) - $binaryPath" "Critical"
                    Write-Finding "  Exploit: Replace with malicious exe" "Critical"
                } catch {}
            }
        }
    }
    
} catch {
    Write-Finding "Error enumerating services: $_" "High"
}

# ============================================================================
# SCHEDULED TASKS
# ============================================================================
Write-SectionHeader "SCHEDULED TASKS"

try {
    Write-Finding "Checking for scheduled tasks with weak permissions..." "Info"
    
    $tasks = Get-ScheduledTask | Where-Object {$_.State -eq "Ready"}
    
    foreach ($task in $tasks) {
        if ($task.Principal.UserId -match "SYSTEM") {
            $actions = $task.Actions
            foreach ($action in $actions) {
                if ($action.Execute) {
                    $execPath = $action.Execute
                    if (Test-Path $execPath -ErrorAction SilentlyContinue) {
                        try {
                            $testFile = $execPath + ".test"
                            [System.IO.File]::Create($testFile).Close()
                            Remove-Item $testFile -ErrorAction SilentlyContinue
                            Write-Finding "Writable SYSTEM Task: $($task.TaskName) - $execPath" "Critical"
                        } catch {}
                    }
                }
            }
        }
    }
} catch {
    Write-Finding "Error checking scheduled tasks: $_" "High"
}

# ============================================================================
# WRITABLE DIRECTORIES IN PATH
# ============================================================================
Write-SectionHeader "WRITABLE DIRECTORIES IN PATH"

try {
    $pathDirs = $env:PATH -split ";"
    
    foreach ($dir in $pathDirs) {
        if ($dir -and (Test-Path $dir -ErrorAction SilentlyContinue)) {
            try {
                $testFile = Join-Path $dir "test.dll"
                [System.IO.File]::Create($testFile).Close()
                Remove-Item $testFile -ErrorAction SilentlyContinue
                Write-Finding "Writable PATH directory: $dir" "High"
                Write-Finding "  Exploit: DLL hijacking via malicious DLL" "High"
            } catch {}
        }
    }
} catch {
    Write-Finding "Error checking PATH directories: $_" "High"
}

# ============================================================================
# AUTORUN ENTRIES
# ============================================================================
Write-SectionHeader "AUTORUN ENTRIES"

try {
    Write-Finding "Checking common autorun locations..." "Info"
    
    $autorunKeys = @(
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce",
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"
    )
    
    foreach ($key in $autorunKeys) {
        if (Test-Path $key) {
            $entries = Get-ItemProperty -Path $key -ErrorAction SilentlyContinue
            if ($entries) {
                Write-Finding "`nAutorun entries in $key" "Info"
                $entries.PSObject.Properties | Where-Object {$_.Name -notmatch "^PS"} | ForEach-Object {
                    Write-Finding "$($_.Name): $($_.Value)" "Medium"
                    
                    $filePath = $_.Value -replace '"', '' -replace ' .*$', ''
                    if (Test-Path $filePath -ErrorAction SilentlyContinue) {
                        try {
                            $testFile = $filePath + ".test"
                            [System.IO.File]::Create($testFile).Close()
                            Remove-Item $testFile -ErrorAction SilentlyContinue
                            Write-Finding "  ^-- File is WRITABLE!" "Critical"
                        } catch {}
                    }
                }
            }
        }
    }
} catch {
    Write-Finding "Error checking autorun entries: $_" "High"
}

# ============================================================================
# CREDENTIAL HUNTING
# ============================================================================
Write-SectionHeader "CREDENTIAL HUNTING"

try {
    Write-Finding "Searching for credential files..." "Info"
    
    # Common credential files
    $interestingFiles = @(
        "$env:USERPROFILE\Unattend.xml",
        "C:\Unattend.xml",
        "C:\Windows\Panther\Unattend.xml",
        "C:\Windows\Panther\Unattend\Unattend.xml",
        "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt"
    )
    
    foreach ($file in $interestingFiles) {
        if (Test-Path $file -ErrorAction SilentlyContinue) {
            Write-Finding "Found: $file" "High"
        }
    }
    
    # Registry credentials
    Write-Finding "`nChecking registry for credentials..." "Info"
    
    # AutoLogon
    $autologon = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" -ErrorAction SilentlyContinue
    if ($autologon.DefaultUserName) {
        Write-Finding "AutoLogon configured for: $($autologon.DefaultUserName)" "High"
        if ($autologon.DefaultPassword) {
            Write-Finding "  Password found in registry!" "Critical"
        }
    }
    
    # VNC
    $vncKeys = @(
        "HKCU:\Software\ORL\WinVNC3\Password",
        "HKCU:\Software\RealVNC\WinVNC4"
    )
    foreach ($key in $vncKeys) {
        if (Test-Path $key -ErrorAction SilentlyContinue) {
            Write-Finding "VNC password registry key found: $key" "High"
        }
    }
    
    # PuTTY
    if (Test-Path "HKCU:\Software\SimonTatham\PuTTY\Sessions" -ErrorAction SilentlyContinue) {
        Write-Finding "PuTTY sessions found in registry" "High"
        Get-ChildItem "HKCU:\Software\SimonTatham\PuTTY\Sessions" -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Finding "  Session: $($_.PSChildName)" "Medium"
        }
    }
    
    # WiFi Passwords
    Write-Finding "`nExtracting WiFi passwords..." "Info"
    $wifiProfiles = netsh wlan show profiles | Select-String "All User Profile" | ForEach-Object {
        $_ -replace ".*:\s+"
    }
    
    foreach ($profile in $wifiProfiles) {
        $profileInfo = netsh wlan show profile name="$profile" key=clear 2>$null
        $password = $profileInfo | Select-String "Key Content" | ForEach-Object {
            $_ -replace ".*:\s+"
        }
        if ($password) {
            Write-Finding "WiFi: $profile - Password: $password" "High"
        }
    }
    
} catch {
    Write-Finding "Error in credential hunting: $_" "High"
}

# ============================================================================
# PROCESS ENUMERATION
# ============================================================================
Write-SectionHeader "PROCESS ENUMERATION"

try {
    Write-Finding "Enumerating processes..." "Info"
    
    # SYSTEM processes
    Write-Finding "`nProcesses running as SYSTEM:" "Info"
    $processes = Get-WmiObject Win32_Process
    $systemProcs = $processes | Where-Object {
        $owner = $_.GetOwner()
        $owner.User -eq "SYSTEM"
    } | Select-Object ProcessId, Name -First 20
    
    foreach ($proc in $systemProcs) {
        Write-Finding "  PID $($proc.ProcessId): $($proc.Name)" "Medium"
    }
    
} catch {
    Write-Finding "Error enumerating processes: $_" "High"
}

# ============================================================================
# KERNEL EXPLOIT DETECTION
# ============================================================================
Write-SectionHeader "KERNEL EXPLOIT DETECTION"

try {
    Write-Finding "Checking for known kernel exploits..." "Info"
    
    $buildNumber = (Get-WmiObject Win32_OperatingSystem).BuildNumber
    Write-Finding "Build Number: $buildNumber" "Info"
    
    $exploits = @{
        "7600" = @("MS10-015", "MS10-092", "MS11-046")
        "7601" = @("MS11-046", "MS13-053", "MS15-051", "MS16-032")
        "9200" = @("MS13-053", "MS15-051", "MS16-032")
        "9600" = @("MS14-058", "MS15-051", "MS16-032", "MS16-135")
        "10240" = @("MS16-032", "MS16-135")
        "10586" = @("MS16-032", "MS16-135")
        "14393" = @("MS16-135", "CVE-2017-0213")
        "15063" = @("CVE-2017-0213")
        "16299" = @("CVE-2018-8120")
        "17134" = @("CVE-2018-8611")
        "17763" = @("CVE-2019-1064", "CVE-2019-1130")
        "18362" = @("CVE-2019-1253", "CVE-2019-1315")
        "18363" = @("CVE-2020-0668", "CVE-2020-0683")
        "19041" = @("CVE-2020-1054")
        "19042" = @("CVE-2021-1732")
        "22000" = @("CVE-2021-36934 HiveNightmare")
    }
    
    if ($exploits.ContainsKey($buildNumber)) {
        Write-Finding "`nPotentially vulnerable to:" "Critical"
        foreach ($exploit in $exploits[$buildNumber]) {
            Write-Finding "  - $exploit" "Critical"
        }
    } else {
        Write-Finding "Build not in vulnerability database (patched or too new)" "Info"
    }
    
} catch {
    Write-Finding "Error checking kernel exploits: $_" "High"
}

# ============================================================================
# NAMED PIPES
# ============================================================================
Write-SectionHeader "NAMED PIPES"

try {
    Write-Finding "Enumerating named pipes..." "Info"
    
    $pipes = [System.IO.Directory]::GetFiles("\\.\\pipe\\")
    Write-Finding "Total pipes: $($pipes.Count)" "Info"
    
    $interestingPipes = @("lsass", "sam", "winreg", "spoolss")
    foreach ($pipe in $pipes) {
        $pipeName = [System.IO.Path]::GetFileName($pipe)
        foreach ($interesting in $interestingPipes) {
            if ($pipeName -like "*$interesting*") {
                Write-Finding "  Interesting: $pipeName" "Medium"
            }
        }
    }
    
} catch {
    Write-Finding "Error enumerating pipes: $_" "High"
}

# ============================================================================
# DRIVER ENUMERATION
# ============================================================================
Write-SectionHeader "DRIVER ENUMERATION"

try {
    Write-Finding "Checking drivers..." "Info"
    
    $drivers = driverquery /v /fo csv | ConvertFrom-Csv
    $unsigned = $drivers | Where-Object {$_.Signed -eq "False"}
    
    if ($unsigned) {
        Write-Finding "Unsigned drivers found:" "High"
        $unsigned | Select-Object -First 10 | ForEach-Object {
            Write-Finding "  $($_.'Module Name')" "High"
        }
    }
    
    # Known vulnerable drivers
    $vulnDrivers = @("rtcore64.sys", "gdrv.sys", "capcom.sys")
    $driverList = $drivers | Select-Object -ExpandProperty 'Module Name'
    foreach ($vuln in $vulnDrivers) {
        if ($driverList -contains $vuln) {
            Write-Finding "VULNERABLE DRIVER: $vuln (BYOVD attack possible)" "Critical"
        }
    }
    
} catch {
    Write-Finding "Error checking drivers: $_" "High"
}

# ============================================================================
# APPLOCKER CHECK
# ============================================================================
Write-SectionHeader "APPLOCKER / WDAC"

try {
    Write-Finding "Checking AppLocker..." "Info"
    
    $appLockerPolicy = Get-AppLockerPolicy -Effective -ErrorAction SilentlyContinue
    
    if ($appLockerPolicy) {
        Write-Finding "AppLocker IS configured!" "Info"
        
        # Check for bypass paths
        $bypassPaths = @(
            "C:\Windows\Tasks",
            "C:\Windows\Temp",
            "C:\Windows\tracing",
            "C:\Windows\System32\spool\drivers\color"
        )
        
        foreach ($path in $bypassPaths) {
            if (Test-Path $path) {
                try {
                    $testFile = Join-Path $path "test.exe"
                    [System.IO.File]::Create($testFile).Close()
                    Remove-Item $testFile -ErrorAction SilentlyContinue
                    Write-Finding "WRITABLE AppLocker bypass path: $path" "Critical"
                } catch {}
            }
        }
    } else {
        Write-Finding "AppLocker not configured" "Info"
    }
    
} catch {
    Write-Finding "Error checking AppLocker: $_" "High"
}

# ============================================================================
# STARTUP FOLDERS
# ============================================================================
Write-SectionHeader "STARTUP FOLDERS"

try {
    Write-Finding "Checking startup folders..." "Info"
    
    $startupFolders = @(
        "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup",
        "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
    )
    
    foreach ($folder in $startupFolders) {
        if (Test-Path $folder) {
            Write-Finding "`nStartup: $folder" "Info"
            $items = Get-ChildItem $folder -ErrorAction SilentlyContinue
            foreach ($item in $items) {
                Write-Finding "  Contains: $($item.Name)" "Medium"
            }
            
            try {
                $testFile = Join-Path $folder "test.exe"
                [System.IO.File]::Create($testFile).Close()
                Remove-Item $testFile -ErrorAction SilentlyContinue
                Write-Finding "  ^-- Folder is WRITABLE!" "Critical"
            } catch {}
        }
    }
    
} catch {
    Write-Finding "Error checking startup folders: $_" "High"
}

# ============================================================================
# BROWSER CREDENTIALS
# ============================================================================
Write-SectionHeader "BROWSER CREDENTIALS"

try {
    Write-Finding "Checking for browser data..." "Info"
    
    # Chrome
    $chromeLogin = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data"
    if (Test-Path $chromeLogin) {
        Write-Finding "Chrome Login Data found: $chromeLogin" "High"
        Write-Finding "  Use SharpChrome or similar to decrypt" "High"
    }
    
    # Firefox
    $firefoxProfiles = "$env:APPDATA\Mozilla\Firefox\Profiles"
    if (Test-Path $firefoxProfiles) {
        Get-ChildItem $firefoxProfiles -Directory -ErrorAction SilentlyContinue | ForEach-Object {
            $loginJson = Join-Path $_.FullName "logins.json"
            if (Test-Path $loginJson) {
                Write-Finding "Firefox logins: $loginJson" "High"
            }
        }
    }
    
    # Edge
    $edgeLogin = "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Login Data"
    if (Test-Path $edgeLogin) {
        Write-Finding "Edge Login Data found: $edgeLogin" "High"
    }
    
} catch {
    Write-Finding "Error checking browsers: $_" "High"
}

# ============================================================================
# ENVIRONMENT VARIABLES
# ============================================================================
Write-SectionHeader "ENVIRONMENT VARIABLES"

try {
    Write-Finding "Checking environment variables..." "Info"
    
    $envVars = Get-ChildItem Env:
    foreach ($var in $envVars) {
        if ($var.Name -match "PASSWORD|PWD|SECRET|KEY|TOKEN|API") {
            Write-Finding "Suspicious: $($var.Name) = $($var.Value)" "High"
        }
    }
    
    if ($env:PATH -match "^\.;|;\.;|;\.$") {
        Write-Finding "Current directory in PATH - DLL hijacking risk!" "Critical"
    }
    
} catch {
    Write-Finding "Error checking environment: $_" "High"
}

# ============================================================================
# FIREWALL STATUS
# ============================================================================
Write-SectionHeader "FIREWALL STATUS"

try {
    Write-Finding "Checking firewall..." "Info"
    
    $firewallProfiles = Get-NetFirewallProfile -ErrorAction SilentlyContinue
    foreach ($profile in $firewallProfiles) {
        Write-Finding "`n$($profile.Name): $($profile.Enabled)" "Info"
        if (-not $profile.Enabled) {
            Write-Finding "  ^-- FIREWALL DISABLED!" "Critical"
        }
    }
    
} catch {
    Write-Finding "Error checking firewall: $_" "High"
}

# ============================================================================
# WSL CHECK
# ============================================================================
Write-SectionHeader "WINDOWS SUBSYSTEM FOR LINUX"

try {
    Write-Finding "Checking for WSL..." "Info"
    
    $wslInstalled = Get-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux -ErrorAction SilentlyContinue
    
    if ($wslInstalled.State -eq "Enabled") {
        Write-Finding "WSL IS INSTALLED!" "High"
        $wslDistros = wsl.exe -l -v 2>$null
        if ($wslDistros) {
            Write-Finding "Distributions:" "High"
            $wslDistros | ForEach-Object { Write-Finding $_ "Info" }
        }
    } else {
        Write-Finding "WSL not installed" "Info"
    }
    
} catch {
    Write-Finding "Error checking WSL: $_" "High"
}

# ============================================================================
# JUICY FOLDERS
# ============================================================================
Write-SectionHeader "JUICY FOLDERS AND FILES"

try {
    Write-Finding "Searching sensitive locations..." "Info"
    
    # SSH keys
    if (Test-Path "$env:USERPROFILE\.ssh") {
        Write-Finding "`nSSH directory found!" "High"
        Get-ChildItem "$env:USERPROFILE\.ssh" -File -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Finding "  $($_.Name)" "High"
        }
    }
    
    # AWS credentials
    if (Test-Path "$env:USERPROFILE\.aws") {
        Write-Finding "`nAWS credentials found!" "Critical"
    }
    
    # Azure
    if (Test-Path "$env:USERPROFILE\.azure") {
        Write-Finding "Azure CLI credentials found!" "Critical"
    }
    
    # Docker
    if (Test-Path "$env:USERPROFILE\.docker\config.json") {
        Write-Finding "Docker config found (may contain registry creds)!" "High"
    }
    
    # KeePass
    Get-ChildItem "$env:USERPROFILE" -Filter "*.kdbx" -Recurse -ErrorAction SilentlyContinue -Depth 3 | ForEach-Object {
        Write-Finding "KeePass database: $($_.FullName)" "Critical"
    }
    
    # Desktop interesting files
    Get-ChildItem "$env:USERPROFILE\Desktop" -File -ErrorAction SilentlyContinue | Where-Object {
        $_.Extension -match "\.txt|\.key|\.pem|\.ppk"
    } | ForEach-Object {
        Write-Finding "Desktop: $($_.Name)" "Medium"
    }
    
} catch {
    Write-Finding "Error searching folders: $_" "High"
}

# ============================================================================
# AMSI STATUS
# ============================================================================
Write-SectionHeader "AMSI STATUS"

try {
    Write-Finding "Checking AMSI..." "Info"
    
    $amsiLoaded = [AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {$_.Location -like "*amsi.dll*"}
    
    if ($amsiLoaded) {
        Write-Finding "AMSI is loaded" "Info"
    } else {
        Write-Finding "AMSI not loaded in current process" "Medium"
    }
    
    $amsiProviders = Get-ChildItem "HKLM:\SOFTWARE\Microsoft\AMSI\Providers" -ErrorAction SilentlyContinue
    if ($amsiProviders) {
        Write-Finding "AMSI Providers: $($amsiProviders.Count)" "Info"
    }
    
} catch {
    Write-Finding "Error checking AMSI: $_" "High"
}

# ============================================================================
# EVENT LOGS
# ============================================================================
Write-SectionHeader "EVENT LOG ANALYSIS"

try {
    Write-Finding "Checking event logs..." "Info"
    
    # Can we read Security log?
    try {
        $secLog = Get-EventLog -LogName Security -Newest 1 -ErrorAction Stop
        Write-Finding "CAN read Security event log!" "High"
    } catch {
        Write-Finding "Cannot read Security log" "Info"
    }
    
    # Check for cleared logs
    try {
        $clearedLogs = Get-WinEvent -FilterHashtable @{LogName='Security'; ID=1102} -MaxEvents 5 -ErrorAction SilentlyContinue
        if ($clearedLogs) {
            Write-Finding "Security log was CLEARED recently!" "Critical"
            foreach ($event in $clearedLogs) {
                Write-Finding "  At: $($event.TimeCreated)" "Critical"
            }
        }
    } catch {}
    
} catch {
    Write-Finding "Error checking logs: $_" "High"
}

# ============================================================================
# SHADOW COPIES
# ============================================================================
Write-SectionHeader "SHADOW COPIES (VSS)"

try {
    Write-Finding "Checking shadow copies..." "Info"
    
    $shadowCopies = Get-WmiObject Win32_ShadowCopy -ErrorAction SilentlyContinue
    
    if ($shadowCopies) {
        Write-Finding "Shadow copies found: $($shadowCopies.Count)" "High"
        foreach ($shadow in $shadowCopies) {
            Write-Finding "  ID: $($shadow.ID)" "High"
            Write-Finding "  InstallDate: $($shadow.InstallDate)" "Info"
        }
        Write-Finding "`nShadow copies may contain old credentials!" "High"
    } else {
        Write-Finding "No shadow copies found" "Info"
    }
    
} catch {
    Write-Finding "Error checking shadow copies: $_" "High"
}

# ============================================================================
# PRINT SPOOLER
# ============================================================================
Write-SectionHeader "PRINT SPOOLER"

try {
    Write-Finding "Checking Print Spooler..." "Info"
    
    $spooler = Get-Service -Name Spooler -ErrorAction SilentlyContinue
    
    if ($spooler) {
        Write-Finding "Print Spooler Status: $($spooler.Status)" "Info"
        
        if ($spooler.Status -eq "Running") {
            Write-Finding "Print Spooler RUNNING - PrintNightmare possible!" "Critical"
            Write-Finding "  Exploit: CVE-2021-1675, CVE-2021-34527" "Critical"
            
            $pointAndPrint = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows NT\Printers\PointAndPrint" -ErrorAction SilentlyContinue
            if ($pointAndPrint) {
                if ($pointAndPrint.NoWarningNoElevationOnInstall -eq 1) {
                    Write-Finding "  NoWarningNoElevationOnInstall enabled - VERY VULNERABLE!" "Critical"
                }
            }
        }
    }
    
} catch {
    Write-Finding "Error checking Print Spooler: $_" "High"
}

# ============================================================================
# NETWORK INFORMATION
# ============================================================================
Write-SectionHeader "NETWORK INFORMATION"

try {
    Write-Finding "Network interfaces:" "Info"
    Get-NetIPAddress | Where-Object {$_.AddressFamily -eq "IPv4"} | ForEach-Object {
        Write-Finding "$($_.InterfaceAlias): $($_.IPAddress)" "Info"
    }
    
    Write-Finding "`nListening ports:" "Info"
    Get-NetTCPConnection | Where-Object {$_.State -eq "Listen"} | Select-Object -First 20 LocalAddress,LocalPort | ForEach-Object {
        Write-Finding "$($_.LocalAddress):$($_.LocalPort)" "Info"
    }
    
} catch {
    Write-Finding "Error gathering network info: $_" "High"
}

# ============================================================================
# INSTALLED APPLICATIONS
# ============================================================================
Write-SectionHeader "INSTALLED APPLICATIONS"

try {
    Write-Finding "Checking installed applications..." "Info"
    
    $apps = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
            Where-Object {$_.DisplayName} | 
            Sort-Object DisplayName | 
            Select-Object -First 30
    
    foreach ($app in $apps) {
        Write-Finding "$($app.DisplayName) - $($app.DisplayVersion)" "Info"
    }
    
    Write-Finding "`nTotal: $((Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Where-Object {$_.DisplayName}).Count)" "Info"
    
} catch {
    Write-Finding "Error enumerating applications: $_" "High"
}

# ============================================================================
# SAVED CREDENTIALS
# ============================================================================
Write-SectionHeader "SAVED CREDENTIALS"

try {
    Write-Finding "Checking saved credentials..." "Info"
    
    $savedCreds = cmdkey /list
    if ($savedCreds) {
        Write-Finding "Saved credentials found:" "High"
        $savedCreds | ForEach-Object { Write-Finding $_ "High" }
    } else {
        Write-Finding "No saved credentials" "Info"
    }
    
} catch {
    Write-Finding "Error checking credentials: $_" "High"
}

# ============================================================================
# UAC AND SECURITY POLICIES
# ============================================================================
Write-SectionHeader "UAC AND SECURITY POLICIES"

try {
    Write-Finding "Checking security settings..." "Info"
    
    # UAC
    $uac = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" -ErrorAction SilentlyContinue
    if ($uac.EnableLUA -eq 0) {
        Write-Finding "UAC is DISABLED!" "Critical"
    } else {
        Write-Finding "UAC is enabled" "Info"
        Write-Finding "  ConsentPromptBehaviorAdmin: $($uac.ConsentPromptBehaviorAdmin)" "Info"
    }
    
    # LSA Protection
    $lsa = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -Name RunAsPPL -ErrorAction SilentlyContinue
    if ($lsa.RunAsPPL -eq 1) {
        Write-Finding "LSA Protection ENABLED" "Info"
    } else {
        Write-Finding "LSA Protection DISABLED - credential dumping easier" "High"
    }
    
    # Credential Guard
    $credGuard = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -Name LsaCfgFlags -ErrorAction SilentlyContinue
    if ($credGuard.LsaCfgFlags -ge 1) {
        Write-Finding "Credential Guard ENABLED" "Info"
    } else {
        Write-Finding "Credential Guard DISABLED" "High"
    }
    
    # Windows Defender
    try {
        $defender = Get-MpComputerStatus -ErrorAction SilentlyContinue
        if ($defender) {
            Write-Finding "`nWindows Defender:" "Info"
            Write-Finding "  RealTimeProtection: $($defender.RealTimeProtectionEnabled)" "Info"
            if (-not $defender.RealTimeProtectionEnabled) {
                Write-Finding "  ^-- Real-time protection DISABLED!" "High"
            }
        }
    } catch {}
    
} catch {
    Write-Finding "Error checking security policies: $_" "High"
}

# ============================================================================
# SUMMARY
# ============================================================================
Write-SectionHeader "ENUMERATION COMPLETE"

Write-Finding "Enumeration completed at $(Get-Date)" "Info"
if ($SaveReport) {
    Write-Finding "Report saved to: $OutputPath" "Info"
}

Write-Host "`n========================================" -ForegroundColor Yellow
Write-Host "REMEMBER:" -ForegroundColor Yellow
Write-Host "- Always get authorization before testing" -ForegroundColor Yellow
Write-Host "- This tool is for legal assessments only" -ForegroundColor Yellow
Write-Host "- Document all findings properly" -ForegroundColor Yellow
Write-Host "========================================`n" -ForegroundColor Yellow
